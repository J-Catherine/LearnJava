+   第一题

    可以考虑用 “容斥原理” ——简化速度

+   第二题

    斐波那契数列。扫一遍

+   第三题

    唯一分解定理

+   第四题

    从i=999开始倒着算，j=i，结束条件是 i^2 < max 依次减下去，判断乘出来的数是否是质数，如果是，和当前最大的比

+   第五题

    nn的方法：辗转相除法（最小公倍数）

    yuer的方法：判断每个质数需要乘几次

+   第六题

    没什么好说的

+   第七题

    找第10001个质数。好难哇！

    Euler筛查法——不会写

    暴力做的.....

+   第八题

    读入很麻烦

    ```java
    //把所有内容都当做字符串读入
    String s="0";
            try {  
                FileInputStream in = new FileInputStream("./p8.data"); // 读取文件路径  
                byte bs[] = new byte[in.available()];  
                in.read(bs);
                s = new String(bs);
                in.close();  
            } catch (Exception e) {  
                e.printStackTrace();  
            }
    ```

+   第九题

    枚举就好啦


+   第十题

    欧拉筛法

    找出一个质数后把所有它的倍数都标记掉

+   第十一题

    读入4个for循环（上下对角线）

    ```java
            String[] ss = s.split("\n|\r| ");
    		//用\n和\r还有空格分隔字符串（表示——正则表达式*-以后学）

            for(int i = 0; i < 20; i++){
                for(int j = 0; j < 20; j++){
                    data[i][j] = Integer.parseInt(ss[i*21+j]);//21是回车
                }
            }
    ```

+   第十二题

    先找出三角形数（n(n+1)/2），判断当前三角形数的约数是否≥500。

    约数个数 = (k1+1) * (k2+1) * ...... * (km+1) *， k为某一个质因子的个数

+   第十三题

    +   字符串转数组存的时候高位的数组序号小，需要整体往后挪（提前估计加法和最高是哪一位）

    +   输入很重要！

        先用split分隔空行or空格，再Integer.parseInt(subString(j,j+1))分别存每一位

+   第十五题

    +   状态：当前所处位置（r,c），有441个（21*21）
    +   决策：从上一状态到达当前状态的方法，从(r-1,c)或者(r,c-1)都可以到达，有2个
    +   阶段：根据状态和决策把问题划分成阶段（用递归的时候淡化了阶段，如果用循环写非常注意“阶段”！）
    +   状态转移方程：f(r,c) = f(r-1,c) + f(r, c-1)
    +   o(╥﹏╥)o
    +   直接使用DFS：会有很多重复的，计算大约2^40^ 次（1秒大约可以计算2^30^ 次）——因为每个状态都可能被重复访问多次！
    +   优化版DFS：在初始给每一个状态（位置）标记：如果当前状态未被访问过，则对其进行访问，在访问完成后返回当前状态的sum；如果当前状态被访问过，则直接返回当前状态的标记值   ——   **“记忆化搜索”**

+   第十四题

    +   Map类，（主要包含put、get等函数）

        ```java
        //创建一个Map类对象 —— 默认情况下是String对象
        Map<Long, Long> m = new HashMap<Long, Long>();

        m.get(j);
        m.put(i,n);
        ```

    +   注意数据类型大小，小心int不够大哦~~

+   第二十四题

    temp 要减一！！！！

     result会超int，用flag数组标记是否使用过。用n[i]保存结果，最终直接输出n[i]